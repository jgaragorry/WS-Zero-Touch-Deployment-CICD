# =============================================================================
# WORKSHOP #4: ZERO TOUCH DEPLOYMENT PIPELINE
# Autor: SoftrainCorp Jose Garagorry
# Descripci√≥n: Orquestaci√≥n completa desde el commit hasta el despliegue en AWS.
# =============================================================================

name: "üöÄ Zero Touch Deploy"

# 1. DISPARADORES (TRIGGERS)
# ¬øCu√°ndo se debe ejecutar este robot?
on:
  push:
    branches:
      - main  # Solo cuando se acepta c√≥digo en la rama principal
    paths:
      # Ahorro de dinero: Solo correr si cambian archivos relevantes
      - 'app/**'
      - 'terraform/**'
      - '.github/workflows/deploy.yaml'

# 2. PERMISOS DE SEGURIDAD (OIDC)
# Esto es CRITICO. Permite que GitHub solicite un token temporal a AWS
# sin necesidad de guardar llaves secretas (Access Keys) de larga duraci√≥n.
permissions:
  id-token: write   # Necesario para solicitar el token OIDC
  contents: read    # Necesario para bajar el c√≥digo del repo

# 3. VARIABLES DE ENTORNO GLOBALES
env:
  AWS_REGION: "us-east-1"
  TF_VERSION: "1.10.0"  # Fijamos la versi√≥n para evitar sorpresas

# 4. TRABAJOS (JOBS)
jobs:
  deploy:
    name: "Build & Deploy Infrastructure"
    runs-on: ubuntu-latest # Usamos una m√°quina virtual Linux de GitHub
    defaults:
      run:
        working-directory: ./terraform # Todos los comandos 'terraform' se ejecutan en esta carpeta

    steps:
      # --- FASE 1: PREPARACI√ìN ---
      
      - name: üì• 1. Checkout Code
        uses: actions/checkout@v4
        # Descarga tu c√≥digo del repositorio a la m√°quina virtual.

      - name: üîê 2. Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }} # El ARN que configuraste en los secretos
          aws-region: ${{ env.AWS_REGION }}
          # Aqu√≠ ocurre la magia: GitHub intercambia su identidad por credenciales de AWS temporales.

      - name: üõ†Ô∏è 3. Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          # Instala el binario de Terraform en la m√°quina virtual.

      # --- FASE 2: INFRAESTRUCTURA BASE ---
      
      - name: üèóÔ∏è 4. Terraform Init & Apply (Base)
        run: |
          # Inicializa plugins y backend S3
          terraform init
          
          # Despliega la infraestructura base (Red, ALB, ECR, ECS).
          # TRUCO: Como a√∫n no tenemos nuestra imagen Docker construida,
          # usamos una imagen p√∫blica (Nginx) temporalmente para que ECS no falle.
          terraform apply -auto-approve \
            -var="app_image=public.ecr.aws/nginx/nginx:latest"

      # --- FASE 3: CONSTRUCCI√ìN DE SOFTWARE (CI) ---

      - name: üîç 5. Get ECR Repo URL
        id: ecr
        run: |
          # Le preguntamos a Terraform: "¬øCu√°l es la URL del repo que acabas de crear?"
          # Y la guardamos en una variable de entorno del sistema ($GITHUB_ENV)
          echo "REPO_URL=$(terraform output -raw ecr_repo_url)" >> $GITHUB_ENV

      - name: üê≥ 6. Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        # Autentica el cliente Docker local contra AWS ECR.

      - name: üì¶ 7. Build, Tag, and Push Docker Image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: ${{ env.REPO_URL }}
          IMAGE_TAG: ${{ github.sha }} # Usamos el Hash del Commit como etiqueta (Trazabilidad)
        working-directory: ./app # Nos movemos a la carpeta de la App
        run: |
          echo "Construyendo imagen: $REPOSITORY:$IMAGE_TAG"
          
          # Construye la imagen usando el Dockerfile
          docker build -t $REPOSITORY:$IMAGE_TAG .
          
          # Sube la imagen a tu ECR privado en AWS
          docker push $REPOSITORY:$IMAGE_TAG
          
          # Guardamos la URL completa de la imagen para el siguiente paso
          echo "IMAGE_URI=$REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      # --- FASE 4: DESPLIEGUE FINAL (CD) ---

      - name: üöÄ 8. Deploy New Version via Terraform
        run: |
          echo "Actualizando ECS con la imagen: ${{ env.IMAGE_URI }}"
          
          # Volvemos a correr Terraform, pero esta vez inyectamos
          # la variable 'app_image' con la imagen que ACABAMOS de construir.
          # Esto forzar√° a Fargate a descargar la nueva versi√≥n y reiniciar los contenedores.
          terraform apply -auto-approve \
            -var="app_image=${{ env.IMAGE_URI }}"
            
      - name: ‚úÖ 9. Show Load Balancer URL
        run: |
          echo "DEPLOY SUCCESS!"
          echo "üåç Tu App est√° viva en: http://$(terraform output -raw alb_dns_name)"
